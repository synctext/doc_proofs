// Code generated by protoc-gen-go.
// source: ProofElementStore.proto
// DO NOT EDIT!

/*
Package ProofElementStore is a generated protocol buffer package.

It is generated from these files:
	ProofElementStore.proto

It has these top-level messages:
	ProofElementStore
	SECPProofElementStore
	SECPSHA2ProofElementStore
*/

/*
Copyright (c) 2016 Skuchain,Inc

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
package ProofElementStore

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ProofElementStore_ProofType int32

const (
	ProofElementStore_SECP    ProofElementStore_ProofType = 0
	ProofElementStore_SECPSHA ProofElementStore_ProofType = 1
)

var ProofElementStore_ProofType_name = map[int32]string{
	0: "SECP",
	1: "SECPSHA",
}
var ProofElementStore_ProofType_value = map[string]int32{
	"SECP":    0,
	"SECPSHA": 1,
}

func (x ProofElementStore_ProofType) String() string {
	return proto.EnumName(ProofElementStore_ProofType_name, int32(x))
}

type SECPProofElementStore_ProofElementState int32

const (
	SECPProofElementStore_Initialized SECPProofElementStore_ProofElementState = 0
	SECPProofElementStore_Signed      SECPProofElementStore_ProofElementState = 1
	SECPProofElementStore_Revoked     SECPProofElementStore_ProofElementState = 2
	SECPProofElementStore_Superseded  SECPProofElementStore_ProofElementState = 3
)

var SECPProofElementStore_ProofElementState_name = map[int32]string{
	0: "Initialized",
	1: "Signed",
	2: "Revoked",
	3: "Superseded",
}
var SECPProofElementStore_ProofElementState_value = map[string]int32{
	"Initialized": 0,
	"Signed":      1,
	"Revoked":     2,
	"Superseded":  3,
}

func (x SECPProofElementStore_ProofElementState) String() string {
	return proto.EnumName(SECPProofElementStore_ProofElementState_name, int32(x))
}

type SECPSHA2ProofElementStore_ProofElementState int32

const (
	SECPSHA2ProofElementStore_Initialized SECPSHA2ProofElementStore_ProofElementState = 0
	SECPSHA2ProofElementStore_Signed      SECPSHA2ProofElementStore_ProofElementState = 1
	SECPSHA2ProofElementStore_Revoked     SECPSHA2ProofElementStore_ProofElementState = 2
	SECPSHA2ProofElementStore_Superseded  SECPSHA2ProofElementStore_ProofElementState = 3
)

var SECPSHA2ProofElementStore_ProofElementState_name = map[int32]string{
	0: "Initialized",
	1: "Signed",
	2: "Revoked",
	3: "Superseded",
}
var SECPSHA2ProofElementStore_ProofElementState_value = map[string]int32{
	"Initialized": 0,
	"Signed":      1,
	"Revoked":     2,
	"Superseded":  3,
}

func (x SECPSHA2ProofElementStore_ProofElementState) String() string {
	return proto.EnumName(SECPSHA2ProofElementStore_ProofElementState_name, int32(x))
}

type ProofElementStore struct {
	Type    ProofElementStore_ProofType `protobuf:"varint,1,opt,name=type,enum=ProofElementStore_ProofType" json:"type,omitempty"`
	Secp    *SECPProofElementStore      `protobuf:"bytes,2,opt,name=secp" json:"secp,omitempty"`
	Secpsha *SECPSHA2ProofElementStore  `protobuf:"bytes,3,opt,name=secpsha" json:"secpsha,omitempty"`
}

func (m *ProofElementStore) Reset()         { *m = ProofElementStore{} }
func (m *ProofElementStore) String() string { return proto.CompactTextString(m) }
func (*ProofElementStore) ProtoMessage()    {}

func (m *ProofElementStore) GetSecp() *SECPProofElementStore {
	if m != nil {
		return m.Secp
	}
	return nil
}

func (m *ProofElementStore) GetSecpsha() *SECPSHA2ProofElementStore {
	if m != nil {
		return m.Secpsha
	}
	return nil
}

type SECPProofElementStore struct {
	Name         string                                  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	State        SECPProofElementStore_ProofElementState `protobuf:"varint,2,opt,name=state,enum=SECPProofElementStore_ProofElementState" json:"state,omitempty"`
	Threshold    int32                                   `protobuf:"varint,3,opt,name=threshold" json:"threshold,omitempty"`
	Data         string                                  `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	PublicKeys   [][]byte                                `protobuf:"bytes,5,rep,name=PublicKeys,proto3" json:"PublicKeys,omitempty"`
	Signatures   [][]byte                                `protobuf:"bytes,6,rep,name=Signatures,proto3" json:"Signatures,omitempty"`
	SupersededBy string                                  `protobuf:"bytes,7,opt,name=SupersededBy" json:"SupersededBy,omitempty"`
}

func (m *SECPProofElementStore) Reset()         { *m = SECPProofElementStore{} }
func (m *SECPProofElementStore) String() string { return proto.CompactTextString(m) }
func (*SECPProofElementStore) ProtoMessage()    {}

type SECPSHA2ProofElementStore struct {
	Name         string                                      `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	State        SECPSHA2ProofElementStore_ProofElementState `protobuf:"varint,2,opt,name=state,enum=SECPSHA2ProofElementStore_ProofElementState" json:"state,omitempty"`
	Threshold    int32                                       `protobuf:"varint,3,opt,name=threshold" json:"threshold,omitempty"`
	Data         string                                      `protobuf:"bytes,4,opt,name=data" json:"data,omitempty"`
	PublicKeys   [][]byte                                    `protobuf:"bytes,5,rep,name=PublicKeys,proto3" json:"PublicKeys,omitempty"`
	Signatures   [][]byte                                    `protobuf:"bytes,6,rep,name=Signatures,proto3" json:"Signatures,omitempty"`
	Digests      [][]byte                                    `protobuf:"bytes,7,rep,name=Digests,proto3" json:"Digests,omitempty"`
	Preimages    [][]byte                                    `protobuf:"bytes,8,rep,name=Preimages,proto3" json:"Preimages,omitempty"`
	SupersededBy string                                      `protobuf:"bytes,9,opt,name=supersededBy" json:"supersededBy,omitempty"`
}

func (m *SECPSHA2ProofElementStore) Reset()         { *m = SECPSHA2ProofElementStore{} }
func (m *SECPSHA2ProofElementStore) String() string { return proto.CompactTextString(m) }
func (*SECPSHA2ProofElementStore) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("ProofElementStore_ProofType", ProofElementStore_ProofType_name, ProofElementStore_ProofType_value)
	proto.RegisterEnum("SECPProofElementStore_ProofElementState", SECPProofElementStore_ProofElementState_name, SECPProofElementStore_ProofElementState_value)
	proto.RegisterEnum("SECPSHA2ProofElementStore_ProofElementState", SECPSHA2ProofElementStore_ProofElementState_name, SECPSHA2ProofElementStore_ProofElementState_value)
}
